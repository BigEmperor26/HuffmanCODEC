\section{Introduction}
The \emph{Huffman algorithm} is designed to find a more convenient bit representation to store data through lossless compression. Instead of considering groups of eight bits to encode data, the Huffman algorithm uses variable-length sequences of bits defined as \emph{alphabet}.

The objective of our work is to build a scalable Huffman encoder and decoder that are able to exploit the provided hardware resources. Moreover, the application should handle both single files and nested folders properly.

Even if nowadays the Huffman algorithm is mainly used for teaching purposes, its prefix mechanism is still part of many notable standards, such as Deflate (PKZIP's algorithm), JPEG, and MP3 compression algorithms. For this reason, there are no state-of-the-art online-available implementations to compare our tool with. In fact, differently from our work, many of the tools we found do not consider:
\begin{itemize}
    \item low-level optimizations, such as to use in-memory buffers to speed up I/O timings\cite{HuffmanParallel,ParallelizedTextCompressio,HuffmanParallel2,Huffman,HuffmanCoding};
    \item handling files of size bigger than some GiBs\cite{HuffmanParallel,ParallelizedTextCompressio,ParallelHuffmanEncoding,HuffmanParallel2,HuffmanCoding,HuffmanCodingMPICUDA};
    \item handling nested folders \cite{HuffmanParallel,ParallelizedTextCompressio,ParallelHuffmanEncoding,HuffmanParallel2,Huffman,pdsAssignment4,HuffmanCoding,HuffmanCodingMPICUDA}.
\end{itemize}
